<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Eisenhower Matrix (Confirm → Settle → WebAR)</title>

  <!-- WebAR libs (MindAR + A-Frame) -->
  <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.5/dist/mindar-image.prod.js"></script>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --pink:#f7d6d9;
      --yellow:#f6e6a8;
      --cream:#fbf7e9;
      --border:#1f1f1f;
      --text:#111;
      --muted:#666;
      --btn:#b9ff9e;
      --btnDisabled:#d9d9d9;
      --btnText:#0b0b0b;
      --danger:#ff5a5a;
      --blue:#0b51ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--text);}

    .app{
      height:100%;
      padding: 14px 14px calc(14px + env(safe-area-inset-bottom));
      padding-top: calc(14px + env(safe-area-inset-top));
      display:flex;
      flex-direction:column;
      gap:12px;
      max-width:420px;
      margin:0 auto;
    }
    .view{display:none; height:100%;}
    .view.active{display:flex; flex-direction:column; gap:12px;}

    /* MATRIX */
    .matrix{
      flex:1;
      border:1px solid var(--border);
      display:grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap:0;
    }
    .quad{
      padding:10px;
      font-size:12px;
      line-height:1.2;
      position:relative;
      overflow:hidden;
      border-right:1px solid rgba(0,0,0,.12);
      border-bottom:1px solid rgba(0,0,0,.12);
      cursor:pointer;
    }
    .quad:nth-child(2), .quad:nth-child(4){ border-right:none; }
    .quad:nth-child(3), .quad:nth-child(4){ border-bottom:none; }

    .quad.pink{ background: var(--pink); }
    .quad.yellow{ background: var(--yellow); }
    .quad.cream{ background: var(--cream); }

    .quadTitle{ font-weight:600; margin-bottom:8px; }
    .preview{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-top:4px;
    }
    .previewItem{
      font-size:11px;
      color: rgba(0,0,0,.75);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .previewItem.done{ text-decoration: line-through; color: rgba(0,0,0,.45); }

    .bottomBar{
      display:flex;
      justify-content:center;
      padding-top: 6px;
    }
    .bigBtn{
      width: 180px;
      height: 34px;
      border:none;
      background: var(--btn);
      color: var(--btnText);
      font-weight:600;
      cursor:pointer;
    }
    .bigBtn:disabled{
      background: var(--btnDisabled);
      color: rgba(0,0,0,.45);
      cursor:not-allowed;
    }
    .tinyNote{
      font-size:12px;
      color: var(--muted);
      text-align:center;
      min-height: 16px;
      line-height:1.25;
    }

    /* CATEGORY VIEW */
    .catPanel{
      flex:1;
      border:1px solid var(--border);
      display:flex;
      flex-direction:column;
      background: var(--pink);
      padding: 12px;
      position:relative;
      overflow:hidden;
    }
    .catPanel.yellowBg{ background: var(--yellow); }
    .catPanel.creamBg{ background: var(--cream); }

    .catHeader{
      font-size:22px;
      font-weight:700;
      line-height:1.05;
      margin-bottom: 10px;
    }
    .list{
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      flex:1;
      padding-right:2px;
    }

    /* Planning row: swipe-to-delete + editable */
    .swipeWrap{
      position:relative;
      overflow:hidden;
    }
    .deleteBg{
      position:absolute;
      inset:0;
      background: var(--danger);
      display:flex;
      justify-content:flex-end;
      align-items:center;
      padding-right:12px;
      color:#fff;
      font-weight:700;
      pointer-events:none;
    }
    .row{
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(0,0,0,.18);
      padding: 8px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      transform: translateX(0px);
      transition: transform .15s ease;
      touch-action: pan-y;
    }

    .textBox{
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .textView{
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding: 2px 4px;
    }
    .editInput{
      width:100%;
      font-size:12px;
      padding: 6px 6px;
      border:1px solid rgba(0,0,0,.25);
      background: rgba(255,255,255,.9);
      outline:none;
      display:none;
    }

    /* Check row base (used in settlement + read-only category view) */
    .rowCheck{
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(0,0,0,.18);
      padding: 8px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .rowCheck.done .checkText{ text-decoration: line-through; color: rgba(0,0,0,.45); }
    .checkText{
      flex:1;
      min-width:0;
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding: 2px 4px;
    }

    /* Switch (only in Settlement screen) */
    .switch{
      position:relative;
      width:38px;
      height:22px;
      flex:0 0 auto;
    }
    .switch input{ display:none; }
    .slider{
      position:absolute; inset:0;
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(0,0,0,.18);
      border-radius:999px;
      transition:.18s;
    }
    .slider:before{
      content:"";
      position:absolute;
      width:16px; height:16px;
      left:3px; top:2px;
      background:#cfcfcf;
      border-radius:50%;
      transition:.18s;
    }
    .switch input:checked + .slider{
      background: rgba(95,215,120,.55);
    }
    .switch input:checked + .slider:before{
      transform: translateX(16px);
      background:#fff;
    }

    /* Floating + (only in Planning mode) */
    .fab{
      position:absolute;
      left:50%;
      bottom: 64px;
      transform: translateX(-50%);
      width:56px;
      height:56px;
      border-radius:999px;
      border:none;
      background:#fff;
      box-shadow: 0 6px 20px rgba(0,0,0,.18);
      font-size:30px;
      line-height:56px;
      text-align:center;
      cursor:pointer;
    }
    .fab:disabled{
      opacity:.35;
      cursor:not-allowed;
    }

    /* Back button row */
    .backBar{
      display:flex;
      justify-content:center;
      padding-top: 6px;
      gap:12px;
    }

    /* SETTLEMENT VIEW */
    .settlePanel{
      flex:1;
      border:1px solid var(--border);
      background: var(--cream);
      padding:12px;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .settleHeader{
      font-size:20px;
      font-weight:800;
      line-height:1.05;
      margin-bottom:6px;
    }
    .settleSub{
      font-size:12px;
      color: rgba(0,0,0,.62);
      line-height:1.25;
      margin-bottom:10px;
    }
    .groupTitle{
      font-size:12px;
      font-weight:800;
      margin: 10px 0 6px;
      opacity:.75;
    }

    /* AR overlay */
    #arOverlay{
      position:fixed;
      inset:0;
      background:#000;
      z-index:9999;
      display:none;
      color:#fff;
      padding: 18px 18px calc(18px + env(safe-area-inset-bottom));
      padding-top: calc(18px + env(safe-area-inset-top));
    }
    #arOverlay.show{ display:flex; flex-direction:column; gap:12px; }

    #arSceneWrap{
      position:absolute;
      inset:0;
      z-index:0;
    }
    #arHud{
      position:relative;
      z-index:1;
      display:flex;
      flex-direction:column;
      gap:12px;
      height:100%;
    }
    .arTitle{ font-size:20px; font-weight:800; text-shadow: 0 2px 12px rgba(0,0,0,.45); }
    .arHint{ font-size:13px; opacity:.95; line-height:1.3; text-shadow: 0 2px 12px rgba(0,0,0,.45); }
    .arSpacer{ flex:1; }
    .arDone{
      height:44px;
      border:none;
      background:#ffffff;
      color: var(--blue);
      font-weight:800;
      cursor:pointer;
      border-radius:12px;
    }
  </style>
</head>

<body>
  <div class="app">

    <!-- MATRIX VIEW -->
    <section id="matrixView" class="view active">
      <div class="matrix" id="matrixGrid">
        <div class="quad pink" data-cat="IU">
          <div class="quadTitle">Urgent,<br>Important</div>
          <div class="preview" id="previewIU"></div>
        </div>
        <div class="quad pink" data-cat="IN">
          <div class="quadTitle">Not Urgent,<br>Important</div>
          <div class="preview" id="previewIN"></div>
        </div>
        <div class="quad yellow" data-cat="NU">
          <div class="quadTitle">Urgent,<br>Not Important</div>
          <div class="preview" id="previewNU"></div>
        </div>
        <div class="quad cream" data-cat="NN">
          <div class="quadTitle">Not Urgent,<br>Not Important</div>
          <div class="preview" id="previewNN"></div>
        </div>
      </div>

      <div class="bottomBar">
        <button id="mainBtn" class="bigBtn" disabled>Confirm</button>
      </div>

      <div class="tinyNote" id="mainNote"></div>
    </section>

    <!-- CATEGORY VIEW -->
    <section id="catView" class="view">
      <div id="catPanel" class="catPanel">
        <div class="catHeader" id="catHeader">Urgent,<br>Important</div>
        <div class="list" id="catList"></div>
        <button id="fabAdd" class="fab" title="Add">+</button>
      </div>

      <div class="backBar">
        <button id="backBtn" class="bigBtn">Back</button>
      </div>
    </section>

    <!-- SETTLEMENT VIEW -->
    <section id="settleView" class="view">
      <div class="settlePanel">
        <div class="settleHeader">Settlement</div>
        <div class="settleSub" id="settleNote">
          Mark what you finished. Finalizing opens AR and can only be done once per day.
        </div>
        <div class="list" id="settleList"></div>
      </div>

      <div class="backBar">
        <button id="settleBackBtn" class="bigBtn">Back</button>
        <button id="settleGoBtn" class="bigBtn">View AR</button>
      </div>
    </section>

  </div>

  <!-- WebAR Overlay -->
  <div id="arOverlay">
    <div id="arSceneWrap">
      <a-scene
        id="arScene"
        mindar-image="imageTargetSrc: ./targets.mind; autoStart: false;"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false"
        renderer="colorManagement: true, physicallyCorrectLights: true"
        embedded
      >
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

        <a-entity id="arTarget0" mindar-image-target="targetIndex: 0">
          <a-plane opacity="0.35" height="0.552" width="1"></a-plane>
        </a-entity>
      </a-scene>
    </div>

    <div id="arHud">
      <div class="arTitle">AR View</div>
      <div class="arHint" id="arHint">
        Point your camera at the target texture.<br>
        Tip: matte surface + good light improves tracking.
      </div>
      <div class="arSpacer"></div>
      <button id="arDoneBtn" class="arDone">Done</button>
    </div>
  </div>

<script>
  /***********************
   * Storage + Modes
   ***********************/
  const STORAGE_KEY = "eisen_matrix_v4_state";
  const MODE_KEY    = "eisen_matrix_v4_mode"; // "plan" | "check"
  const CLAIM_KEY   = "eisen_matrix_v4_daily_claim"; // { "YYYY-MM-DD": { claimedAt, snapshot } }

  const MODE = {
    PLAN: "plan",   // only add/edit/delete
    CHECK:"check"   // read-only; settlement required to mark done
  };

  const MAX_PER_CAT = 3; // ✅ changed from 5 to 3

  const CATS = ["IU","IN","NU","NN"];
  const CAT_META = {
    IU: { title: "Urgent,<br>Important", bg: "pink" },
    IN: { title: "Not Urgent,<br>Important", bg: "pink" },
    NU: { title: "Urgent,<br>Not Important", bg: "yellow" },
    NN: { title: "Not Urgent,<br>Not Important", bg: "cream" }
  };

  let state = loadState(); // { IU: Task[], ... } Task: {id,text,done}
  let mode  = loadMode();  // plan/check
  let currentCat = null;

  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return { IU:[], IN:[], NU:[], NN:[] };
      const parsed = JSON.parse(raw);
      for (const c of CATS) if (!Array.isArray(parsed[c])) parsed[c] = [];
      for (const c of CATS){
        parsed[c] = parsed[c].map(t => ({
          id: t.id || cryptoId(),
          text: typeof t.text === "string" ? t.text : "",
          done: !!t.done
        })).slice(0, MAX_PER_CAT); // ✅ enforce max 3 on load
      }
      return parsed;
    }catch{
      return { IU:[], IN:[], NU:[], NN:[] };
    }
  }
  function saveState(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }
  function loadMode(){
    const m = localStorage.getItem(MODE_KEY);
    return (m === MODE.CHECK) ? MODE.CHECK : MODE.PLAN;
  }
  function saveMode(){
    localStorage.setItem(MODE_KEY, mode);
  }
  function cryptoId(){
    return (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(16).slice(2));
  }

  /***********************
   * Daily claim (only once)
   ***********************/
  function localDateKey(d = new Date()){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const da = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }
  function loadClaimMap(){
    try { return JSON.parse(localStorage.getItem(CLAIM_KEY) || "{}"); }
    catch { return {}; }
  }
  function saveClaimMap(map){
    localStorage.setItem(CLAIM_KEY, JSON.stringify(map));
  }
  function hasClaimedToday(){
    const day = localDateKey();
    const map = loadClaimMap();
    return !!map[day]?.claimedAt;
  }
  function claimToday(snapshot){
    const day = localDateKey();
    const map = loadClaimMap();
    map[day] = { claimedAt: Date.now(), snapshot };
    saveClaimMap(map);
  }

  /***********************
   * Helpers
   ***********************/
  function allTasks(){ return CATS.flatMap(c => state[c]); }
  function totalTasks(){ return allTasks().length; }
  function completionRate(){
    const t = allTasks();
    if (!t.length) return 0;
    const d = t.reduce((a,x)=>a+(x.done?1:0),0);
    return Math.round((d/t.length)*100);
  }

  /***********************
   * View switching
   ***********************/
  const matrixView = document.getElementById("matrixView");
  const catView    = document.getElementById("catView");
  const settleView = document.getElementById("settleView");

  const catHeader  = document.getElementById("catHeader");
  const catList    = document.getElementById("catList");
  const catPanel   = document.getElementById("catPanel");
  const fabAdd     = document.getElementById("fabAdd");

  const backBtn    = document.getElementById("backBtn");
  const mainBtn    = document.getElementById("mainBtn");
  const mainNote   = document.getElementById("mainNote");

  const settleList = document.getElementById("settleList");
  const settleNote = document.getElementById("settleNote");
  const settleBackBtn = document.getElementById("settleBackBtn");
  const settleGoBtn   = document.getElementById("settleGoBtn");

  function showMatrix(){
    currentCat = null;
    catView.classList.remove("active");
    settleView.classList.remove("active");
    matrixView.classList.add("active");
    renderMatrix();
  }

  function showCategory(cat){
    currentCat = cat;
    matrixView.classList.remove("active");
    settleView.classList.remove("active");
    catView.classList.add("active");

    catHeader.innerHTML = CAT_META[cat].title;
    catPanel.classList.remove("yellowBg","creamBg");
    if (CAT_META[cat].bg === "yellow") catPanel.classList.add("yellowBg");
    if (CAT_META[cat].bg === "cream")  catPanel.classList.add("creamBg");

    renderCategory(cat);
  }

  function showSettlement(){
    matrixView.classList.remove("active");
    catView.classList.remove("active");
    settleView.classList.add("active");
    renderSettlement();
  }

  backBtn.addEventListener("click", showMatrix);
  settleBackBtn.addEventListener("click", showMatrix);

  document.getElementById("matrixGrid").addEventListener("click", (e) => {
    const quad = e.target.closest(".quad");
    if (!quad) return;
    showCategory(quad.dataset.cat);
  });

  /***********************
   * Matrix render (mode-aware)
   ***********************/
  function renderMatrix(){
    for (const cat of CATS){
      const box = document.getElementById("preview"+cat);
      box.innerHTML = "";
      const items = state[cat].slice(0,3);
      for (const t of items){
        const div = document.createElement("div");
        div.className = "previewItem" + (t.done ? " done" : "");
        div.textContent = "• " + (t.text || "(empty)");
        box.appendChild(div);
      }
    }

    if (mode === MODE.PLAN){
      const canConfirm = totalTasks() > 0;
      mainBtn.textContent = "Confirm";
      mainBtn.disabled = !canConfirm;

      if (!canConfirm){
        mainNote.textContent = "Click a category to add todos. Confirm unlocks after you add at least 1.";
      } else {
        mainNote.textContent = `Max ${MAX_PER_CAT} items per category.`;
      }
    } else {
      const claimed = hasClaimedToday();
      const hasTasks = totalTasks() > 0;

      mainBtn.textContent = claimed ? "Settled today ✅" : "Settle";
      mainBtn.disabled = !hasTasks || claimed;

      if (!hasTasks){
        mainNote.textContent = "No todos. Go back and add tasks first.";
      } else if (claimed){
        mainNote.textContent = "You already finalized settlement today. Come back tomorrow.";
      } else {
        const picked = completionRate();
        mainNote.textContent = picked > 0
          ? `Ready to settle. Currently selected: ${picked}% (you can adjust in Settlement).`
          : "Ready to settle. Tap Settle to mark what you finished (once per day), then view AR.";
      }
    }
  }

  /***********************
   * Category render (mode-aware)
   ***********************/
  function renderCategory(cat){
    catList.innerHTML = "";

    if (mode === MODE.PLAN){
      fabAdd.style.display = "block";
      fabAdd.disabled = state[cat].length >= MAX_PER_CAT; // ✅ max 3

      for (const task of state[cat]){
        const wrap = document.createElement("div");
        wrap.className = "swipeWrap";

        const delBg = document.createElement("div");
        delBg.className = "deleteBg";
        delBg.textContent = "Delete";
        wrap.appendChild(delBg);

        const row = document.createElement("div");
        row.className = "row";
        row.dataset.id = task.id;

        const textBox = document.createElement("div");
        textBox.className = "textBox";

        const textView = document.createElement("div");
        textView.className = "textView";
        textView.textContent = task.text || "tap to edit";

        const edit = document.createElement("input");
        edit.className = "editInput";
        edit.type = "text";
        edit.value = task.text || "";

        textView.addEventListener("click", () => {
          textView.style.display = "none";
          edit.style.display = "block";
          edit.focus();
          edit.setSelectionRange(edit.value.length, edit.value.length);
        });

        function commitEdit(){
          const v = edit.value.trim();
          task.text = v;
          textView.textContent = v || "tap to edit";
          edit.style.display = "none";
          textView.style.display = "block";
          persistAndRerender(cat);
        }
        edit.addEventListener("keydown", (e) => { if (e.key === "Enter") edit.blur(); });
        edit.addEventListener("blur", commitEdit);

        textBox.appendChild(textView);
        textBox.appendChild(edit);

        row.appendChild(textBox);
        wrap.appendChild(row);
        catList.appendChild(wrap);

        attachSwipeToDelete(row, () => {
          state[cat] = state[cat].filter(t => t.id !== task.id);
          persistAndRerender(cat);
        });
      }
    } else {
      // ✅ CHECK mode is read-only now (no toggles here)
      fabAdd.style.display = "none";
      for (const task of state[cat]){
        const row = document.createElement("div");
        row.className = "rowCheck" + (task.done ? " done" : "");
        const text = document.createElement("div");
        text.className = "checkText";
        text.textContent = task.text || "(empty)";
        row.appendChild(text);
        catList.appendChild(row);
      }
    }
  }

  fabAdd.addEventListener("click", () => {
    if (mode !== MODE.PLAN) return;
    if (!currentCat) return;
    if (state[currentCat].length >= MAX_PER_CAT) return; // ✅ max 3

    state[currentCat].push({ id: cryptoId(), text: "", done: false });
    saveState();
    renderCategory(currentCat);

    requestAnimationFrame(() => {
      const lastRow = catList.querySelector(".row:last-child");
      if (!lastRow) return;
      const tv = lastRow.querySelector(".textView");
      tv && tv.click();
    });

    renderMatrix();
  });

  function persistAndRerender(cat){
    // enforce max per cat defensively
    state[cat] = state[cat].slice(0, MAX_PER_CAT);
    saveState();
    renderCategory(cat);
    renderMatrix();
  }

  /***********************
   * Settlement render (one-time finalize)
   ***********************/
  function renderSettlement(){
    settleList.innerHTML = "";

    const claimed = hasClaimedToday();
    settleGoBtn.disabled = claimed || totalTasks() === 0;

    settleNote.textContent = claimed
      ? "You already finalized settlement today. Come back tomorrow."
      : `Mark what you finished. Finalizing opens AR and can only be done once per day.`;

    for (const cat of CATS){
      const tasks = state[cat];
      if (!tasks.length) continue;

      const title = document.createElement("div");
      title.className = "groupTitle";
      title.innerHTML = CAT_META[cat].title.replace("<br>", " ");
      settleList.appendChild(title);

      for (const task of tasks){
        const row = document.createElement("div");
        row.className = "rowCheck" + (task.done ? " done" : "");

        const text = document.createElement("div");
        text.className = "checkText";
        text.textContent = task.text || "(empty)";

        const sw = document.createElement("label");
        sw.className = "switch";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = !!task.done;
        cb.disabled = claimed;

        cb.addEventListener("change", () => {
          task.done = cb.checked;
          saveState();
          renderSettlement();
          renderMatrix();
        });

        const slider = document.createElement("span");
        slider.className = "slider";
        sw.appendChild(cb);
        sw.appendChild(slider);

        row.appendChild(text);
        row.appendChild(sw);
        settleList.appendChild(row);
      }
    }

    if (!claimed && totalTasks() > 0){
      const pct = completionRate();
      settleNote.textContent = `Mark what you finished. Selected: ${pct}%. Finalize to open AR (once/day).`;
    }
  }

  /***********************
   * Swipe to delete (PLAN only)
   ***********************/
  function attachSwipeToDelete(rowEl, onDelete){
    let startX = 0;
    let currentX = 0;
    let dragging = false;

    rowEl.addEventListener("pointerdown", (e) => {
      if (mode !== MODE.PLAN) return;
      if (e.target.closest(".editInput")) return;
      dragging = true;
      startX = e.clientX;
      currentX = 0;
      rowEl.style.transition = "none";
      rowEl.setPointerCapture(e.pointerId);
    });

    rowEl.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - startX;
      currentX = Math.max(-120, Math.min(0, dx));
      rowEl.style.transform = `translateX(${currentX}px)`;
    });

    rowEl.addEventListener("pointerup", () => finishSwipe());
    rowEl.addEventListener("pointercancel", () => finishSwipe());

    function finishSwipe(){
      if (!dragging) return;
      dragging = false;
      rowEl.style.transition = "transform .15s ease";

      if (currentX < -80){
        rowEl.style.transform = "translateX(-120px)";
        setTimeout(() => onDelete(), 120);
      } else {
        rowEl.style.transform = "translateX(0px)";
      }
    }
  }

  /***********************
   * WebAR start/stop
   ***********************/
  const arOverlay = document.getElementById("arOverlay");
  const arDoneBtn = document.getElementById("arDoneBtn");
  const arHint    = document.getElementById("arHint");

  const arScene   = document.getElementById("arScene");
  const arTarget0 = document.getElementById("arTarget0");

  async function startAR(){
    if (!arScene) return;
    const startNow = async () => {
      const sys = arScene.systems && arScene.systems["mindar-image-system"];
      if (!sys) return;
      try { await sys.start(); }
      catch {
        arHint.textContent = "Camera could not start. Use HTTPS (or localhost) and allow camera access.";
      }
    };
    if (arScene.hasLoaded) startNow();
    else arScene.addEventListener("loaded", startNow, { once:true });
  }

  function stopAR(){
    try{
      const sys = arScene.systems && arScene.systems["mindar-image-system"];
      sys && sys.stop();
    }catch{}
  }

  if (arTarget0){
    arTarget0.addEventListener("targetFound", () => {
      arHint.textContent = "Target found ✅ Tracking…";
    });
    arTarget0.addEventListener("targetLost", () => {
      arHint.textContent = "Target lost. Point at the target texture again.";
    });
  }

  /***********************
   * Main button actions
   * PLAN: Confirm -> CHECK (locks list; resets all done to false)
   * CHECK: Settle -> Settlement screen (Finalize once/day) -> View AR
   ***********************/
  mainBtn.addEventListener("click", () => {
    if (mode === MODE.PLAN){
      if (totalTasks() === 0) return;

      // Confirm: enter CHECK mode and reset done flags
      for (const c of CATS) for (const t of state[c]) t.done = false;

      mode = MODE.CHECK;
      saveMode();
      saveState();
      showMatrix();
      return;
    }

    // CHECK: go to settlement screen (no checking in category lists)
    if (hasClaimedToday()) return;
    if (totalTasks() === 0) return;

    const ok = confirm(
      "You will mark completed tasks in a one-time Settlement.\n" +
      "Finalizing Settlement can only be done once per day.\n\n" +
      "Continue to Settlement?"
    );
    if (!ok) return;

    showSettlement();
  });

  // Finalize settlement -> claim today -> open AR
  settleGoBtn.addEventListener("click", () => {
    if (hasClaimedToday()) return;
    if (totalTasks() === 0) return;

    const ok = confirm(
      "Finalize Settlement for today and open AR?\n" +
      "You won't be able to settle again today."
    );
    if (!ok) return;

    const snapshot = {
      day: localDateKey(),
      total: totalTasks(),
      completion: completionRate(),
      byCat: {
        IU: state.IU.length, IN: state.IN.length, NU: state.NU.length, NN: state.NN.length
      }
    };
    claimToday(snapshot);

    arOverlay.classList.add("show");
    startAR();
  });

  // AR Done -> clear all -> back to PLAN
  arDoneBtn.addEventListener("click", () => {
    stopAR();

    state = { IU:[], IN:[], NU:[], NN:[] };
    mode = MODE.PLAN;
    saveMode();
    saveState();

    arOverlay.classList.remove("show");
    showMatrix();
  });

  /***********************
   * Initial render
   ***********************/
  showMatrix();
</script>
</body>
</html>