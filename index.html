<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Eisenhower Matrix (Confirm → Settle → WebAR)</title>

  <!-- ✅ Order matters: A-Frame first, then MindAR A-Frame plugin.
       Kept BOTH MindAR scripts (not deleted), pinned to same version. -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image.prod.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --pink:#f7d6d9;
      --yellow:#f6e6a8;
      --cream:#fbf7e9;
      --border:#1f1f1f;
      --text:#111;
      --muted:#666;
      --btn:#b9ff9e;
      --btnDisabled:#d9d9d9;
      --btnText:#0b0b0b;
      --danger:#ff5a5a;
      --blue:#0b51ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--text);}

    .app{
      height:100%;
      padding: 14px 14px calc(14px + env(safe-area-inset-bottom));
      padding-top: calc(14px + env(safe-area-inset-top));
      display:flex;
      flex-direction:column;
      gap:12px;
      max-width:420px;
      margin:0 auto;
    }
    .view{display:none; height:100%;}
    .view.active{display:flex; flex-direction:column; gap:12px;}

    /* Top bars (text controls) */
    .topBar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      min-height: 28px;
    }
    .textBtn{
      appearance:none;
      border:none;
      background:transparent;
      padding:0;
      font: inherit;
      cursor:pointer;
      color: var(--text);
    }
    .textBtn:disabled{ opacity:.4; cursor:not-allowed; }
    .textBtn.back{
      font-weight:700;
      color: rgba(0,0,0,.85);
    }
    .textBtn.danger{
      font-weight:900;
      color: var(--danger);
    }

    /* MATRIX */
    .matrix{
      flex:1;
      border:1px solid var(--border);
      display:grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap:0;
    }
    .quad{
      padding:10px;
      font-size:12px;
      line-height:1.2;
      position:relative;
      overflow:hidden;
      border-right:1px solid rgba(0,0,0,.12);
      border-bottom:1px solid rgba(0,0,0,.12);
      cursor:pointer;
    }
    .quad:nth-child(2), .quad:nth-child(4){ border-right:none; }
    .quad:nth-child(3), .quad:nth-child(4){ border-bottom:none; }

    .quad.pink{ background: var(--pink); }
    .quad.yellow{ background: var(--yellow); }
    .quad.cream{ background: var(--cream); }

    .quadTitle{ font-weight:600; margin-bottom:8px; }
    .preview{ display:flex; flex-direction:column; gap:6px; margin-top:4px; }
    .previewItem{
      font-size:11px;
      color: rgba(0,0,0,.75);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .previewItem.done{ text-decoration: line-through; color: rgba(0,0,0,.45); }

    .bottomBar{ display:flex; justify-content:center; padding-top:6px; }

    /* Bigger primary buttons (Confirm / Settle / View AR) */
    .primaryBtn{
      width: min(360px, 100%);
      height: 56px;
      border:none;
      border-radius:14px;
      background: var(--btn);
      color: var(--btnText);
      font-weight:900;
      font-size:16px;
      cursor:pointer;
    }
    .primaryBtn:disabled{
      background: var(--btnDisabled);
      color: rgba(0,0,0,.45);
      cursor:not-allowed;
    }

    .tinyNote{
      font-size:12px;
      color: var(--muted);
      text-align:center;
      min-height:16px;
      line-height:1.25;
    }

    /* CATEGORY VIEW */
    .catPanel{
      flex:1;
      border:1px solid var(--border);
      display:flex;
      flex-direction:column;
      background: var(--pink);
      padding: 12px;
      position:relative;
      overflow:hidden;
    }
    .catPanel.yellowBg{ background: var(--yellow); }
    .catPanel.creamBg{ background: var(--cream); }

    .catHeader{
      font-size:22px;
      font-weight:800;
      line-height:1.05;
      margin-bottom:10px;
    }
    .list{
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      flex:1;
      padding-right:2px;
    }

    /* Planning row: swipe-to-delete + editable */
    .swipeWrap{ position:relative; overflow:hidden; border-radius:10px; }
    .deleteBg{
      position:absolute;
      inset:0;
      background: var(--danger);
      display:flex;
      justify-content:flex-end;
      align-items:center;
      padding-right:12px;
      color:#fff;
      font-weight:800;
      pointer-events:none;
    }
    .row{
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(0,0,0,.18);
      padding: 8px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      transform: translateX(0px);
      transition: transform .15s ease;
      touch-action: pan-y;
      border-radius:10px;
    }
    .textBox{ flex:1; min-width:0; display:flex; flex-direction:column; gap:4px; }
    .textView{
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding:2px 4px;
    }
    .editInput{
      width:100%;
      font-size:12px;
      padding:6px 6px;
      border:1px solid rgba(0,0,0,.25);
      background: rgba(255,255,255,.9);
      outline:none;
      display:none;
      border-radius:8px;
    }

    /* Read-only row (category in CHECK + settlement base) */
    .rowCheck{
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(0,0,0,.18);
      padding: 8px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-radius:10px;
    }
    .rowCheck.done .checkText{ text-decoration: line-through; color: rgba(0,0,0,.45); }
    .checkText{
      flex:1;
      min-width:0;
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding:2px 4px;
    }

    /* Switch (Settlement only) */
    .switch{ position:relative; width:38px; height:22px; flex:0 0 auto; }
    .switch input{ display:none; }
    .slider{
      position:absolute; inset:0;
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(0,0,0,.18);
      border-radius:999px;
      transition:.18s;
    }
    .slider:before{
      content:"";
      position:absolute;
      width:16px; height:16px;
      left:3px; top:2px;
      background:#cfcfcf;
      border-radius:50%;
      transition:.18s;
    }
    .switch input:checked + .slider{ background: rgba(95,215,120,.55); }
    .switch input:checked + .slider:before{ transform: translateX(16px); background:#fff; }

    /* Floating + (Planning only) */
    .fab{
      position:absolute;
      left:50%;
      bottom:64px;
      transform: translateX(-50%);
      width:56px;
      height:56px;
      border-radius:999px;
      border:none;
      background:#fff;
      box-shadow: 0 6px 20px rgba(0,0,0,.18);
      font-size:30px;
      line-height:56px;
      text-align:center;
      cursor:pointer;
    }
    .fab:disabled{ opacity:.35; cursor:not-allowed; }

    /* SETTLEMENT */
    .settlePanel{
      flex:1;
      border:1px solid var(--border);
      background: var(--cream);
      padding:12px;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      border-radius:10px;
    }
    .settleHeader{
      font-size:20px;
      font-weight:900;
      line-height:1.05;
      margin-bottom:6px;
    }
    .settleSub{
      font-size:12px;
      color: rgba(0,0,0,.62);
      line-height:1.25;
      margin-bottom:10px;
    }
    .groupTitle{
      font-size:12px;
      font-weight:900;
      margin: 10px 0 6px;
      opacity:.75;
    }

    /* AR overlay */
    #arOverlay{
      position:fixed;
      inset:0;
      background:#000;
      z-index:9999;
      display:none;
      color:#fff;
      padding: 18px 18px calc(18px + env(safe-area-inset-bottom));
      padding-top: calc(18px + env(safe-area-inset-top));
    }
    #arOverlay.show{ display:flex; flex-direction:column; gap:12px; }

    #arSceneWrap{ position:absolute; inset:0; z-index:0; }
    #arScene{
      position:absolute !important;
      inset:0 !important;
      width:100% !important;
      height:100% !important;
    }
    #arScene canvas{ width:100% !important; height:100% !important; }

    #arHud{
      position:relative;
      z-index:1;
      display:flex;
      flex-direction:column;
      gap:12px;
      height:100%;
      pointer-events:none;
    }
    .arTitle{ font-size:20px; font-weight:900; text-shadow: 0 2px 12px rgba(0,0,0,.45); }
    .arHint{ font-size:13px; opacity:.95; line-height:1.3; text-shadow: 0 2px 12px rgba(0,0,0,.45); }
    .arSpacer{ flex:1; }
    .arDone{
      height:44px;
      border:none;
      background:#fff;
      color: var(--blue);
      font-weight:900;
      cursor:pointer;
      border-radius:12px;
      pointer-events:auto;
    }
  </style>
</head>

<body>
  <div class="app">

    <!-- MATRIX VIEW -->
    <section id="matrixView" class="view active">
      <div class="topBar">
        <div></div>
        <button id="newRoundBtn" class="textBtn danger">New Round</button>
      </div>

      <div class="matrix" id="matrixGrid">
        <div class="quad pink" data-cat="IU">
          <div class="quadTitle">Urgent,<br>Important</div>
          <div class="preview" id="previewIU"></div>
        </div>
        <div class="quad pink" data-cat="IN">
          <div class="quadTitle">Not Urgent,<br>Important</div>
          <div class="preview" id="previewIN"></div>
        </div>
        <div class="quad yellow" data-cat="NU">
          <div class="quadTitle">Urgent,<br>Not Important</div>
          <div class="preview" id="previewNU"></div>
        </div>
        <div class="quad cream" data-cat="NN">
          <div class="quadTitle">Not Urgent,<br>Not Important</div>
          <div class="preview" id="previewNN"></div>
        </div>
      </div>

      <div class="bottomBar">
        <button id="mainBtn" class="primaryBtn" disabled>Confirm</button>
      </div>

      <div class="tinyNote" id="mainNote"></div>
    </section>

    <!-- CATEGORY VIEW -->
    <section id="catView" class="view">
      <div class="topBar">
        <button id="backBtn" class="textBtn back">← Back</button>
        <div></div>
      </div>

      <div id="catPanel" class="catPanel">
        <div class="catHeader" id="catHeader">Urgent,<br>Important</div>
        <div class="list" id="catList"></div>
        <button id="fabAdd" class="fab" title="Add">+</button>
      </div>
    </section>

    <!-- SETTLEMENT VIEW -->
    <section id="settleView" class="view">
      <div class="topBar">
        <button id="settleBackBtn" class="textBtn back">← Back</button>
        <div></div>
      </div>

      <div class="settlePanel">
        <div class="settleHeader">Settlement</div>
        <div class="settleSub" id="settleNote">Mark done → AR.</div>
        <div class="list" id="settleList"></div>
      </div>

      <div class="bottomBar">
        <button id="settleGoBtn" class="primaryBtn">View AR</button>
      </div>
    </section>

  </div>

  <!-- WebAR Overlay -->
  <div id="arOverlay">
    <div id="arSceneWrap">
      <a-scene
        id="arScene"
        mindar-image="imageTargetSrc: ./targets.mind; autoStart: false;"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false"
        renderer="colorManagement: true, physicallyCorrectLights: true"
        embedded
      >
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

        <a-entity id="arTarget0" mindar-image-target="targetIndex: 0">
          <a-plane opacity="0.35" height="0.552" width="1"></a-plane>
        </a-entity>
      </a-scene>
    </div>

    <div id="arHud">
      <div class="arTitle">AR</div>
      <div class="arHint" id="arHint">Point at target.</div>
      <div class="arSpacer"></div>
      <button id="arDoneBtn" class="arDone">Done</button>
    </div>
  </div>

<script>
  /***********************
   * Storage + Modes
   ***********************/
  const STORAGE_KEY = "eisen_matrix_v4_state";
  const MODE_KEY    = "eisen_matrix_v4_mode";
  const ROUND_KEY   = "eisen_matrix_v4_round"; // { id, settledAt, snapshot }

  const MODE = { PLAN:"plan", CHECK:"check" };
  const MAX_PER_CAT = 3;

  const CATS = ["IU","IN","NU","NN"];
  const CAT_META = {
    IU: { title: "Urgent,<br>Important", bg: "pink" },
    IN: { title: "Not Urgent,<br>Important", bg: "pink" },
    NU: { title: "Urgent,<br>Not Important", bg: "yellow" },
    NN: { title: "Not Urgent,<br>Not Important", bg: "cream" }
  };

  let state = loadState();
  let mode  = loadMode();
  let round = loadRound();
  let currentCat = null;

  function cryptoId(){
    return (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(16).slice(2));
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return { IU:[], IN:[], NU:[], NN:[] };
      const parsed = JSON.parse(raw);
      for (const c of CATS) if (!Array.isArray(parsed[c])) parsed[c] = [];
      for (const c of CATS){
        parsed[c] = parsed[c].map(t => ({
          id: t.id || cryptoId(),
          text: typeof t.text === "string" ? t.text : "",
          done: !!t.done
        })).slice(0, MAX_PER_CAT);
      }
      return parsed;
    }catch{
      return { IU:[], IN:[], NU:[], NN:[] };
    }
  }
  function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

  function loadMode(){
    const m = localStorage.getItem(MODE_KEY);
    return (m === MODE.CHECK) ? MODE.CHECK : MODE.PLAN;
  }
  function saveMode(){ localStorage.setItem(MODE_KEY, mode); }

  function loadRound(){
    try{
      const raw = localStorage.getItem(ROUND_KEY);
      if (!raw) return null;
      const r = JSON.parse(raw);
      if (!r || typeof r.id !== "string") return null;
      return {
        id: r.id,
        settledAt: (typeof r.settledAt === "number") ? r.settledAt : null,
        snapshot: r.snapshot || null
      };
    }catch{
      return null;
    }
  }
  function saveRound(){
    if (!round) localStorage.removeItem(ROUND_KEY);
    else localStorage.setItem(ROUND_KEY, JSON.stringify(round));
  }
  function isRoundSettled(){ return !!round?.settledAt; }
  function startRound(){ round = { id: cryptoId(), settledAt: null, snapshot: null }; saveRound(); }
  function settleRound(snapshot){
    if (!round) startRound();
    round.settledAt = Date.now();
    round.snapshot = snapshot || null;
    saveRound();
  }
  function clearRound(){ round = null; saveRound(); }

  if (mode === MODE.CHECK && !round) startRound();

  /***********************
   * Helpers
   ***********************/
  function allTasks(){ return CATS.flatMap(c => state[c]); }
  function totalTasks(){ return allTasks().length; }

  /***********************
   * Views
   ***********************/
  const matrixView = document.getElementById("matrixView");
  const catView    = document.getElementById("catView");
  const settleView = document.getElementById("settleView");

  const catHeader  = document.getElementById("catHeader");
  const catList    = document.getElementById("catList");
  const catPanel   = document.getElementById("catPanel");
  const fabAdd     = document.getElementById("fabAdd");

  const backBtn     = document.getElementById("backBtn");
  const mainBtn     = document.getElementById("mainBtn");
  const mainNote    = document.getElementById("mainNote");
  const newRoundBtn = document.getElementById("newRoundBtn");

  const settleList    = document.getElementById("settleList");
  const settleNote    = document.getElementById("settleNote");
  const settleBackBtn = document.getElementById("settleBackBtn");
  const settleGoBtn   = document.getElementById("settleGoBtn");

  function showMatrix(){
    currentCat = null;
    catView.classList.remove("active");
    settleView.classList.remove("active");
    matrixView.classList.add("active");
    renderMatrix();
  }

  function showCategory(cat){
    currentCat = cat;
    matrixView.classList.remove("active");
    settleView.classList.remove("active");
    catView.classList.add("active");

    catHeader.innerHTML = CAT_META[cat].title;
    catPanel.classList.remove("yellowBg","creamBg");
    if (CAT_META[cat].bg === "yellow") catPanel.classList.add("yellowBg");
    if (CAT_META[cat].bg === "cream")  catPanel.classList.add("creamBg");

    renderCategory(cat);
  }

  function showSettlement(){
    matrixView.classList.remove("active");
    catView.classList.remove("active");
    settleView.classList.add("active");
    renderSettlement();
  }

  backBtn.addEventListener("click", showMatrix);
  settleBackBtn.addEventListener("click", showMatrix);

  document.getElementById("matrixGrid").addEventListener("click", (e) => {
    const quad = e.target.closest(".quad");
    if (!quad) return;
    showCategory(quad.dataset.cat);
  });

  /***********************
   * Render: Matrix
   ***********************/
  function renderMatrix(){
    for (const cat of CATS){
      const box = document.getElementById("preview"+cat);
      box.innerHTML = "";
      const items = state[cat].slice(0,3);
      for (const t of items){
        const div = document.createElement("div");
        div.className = "previewItem" + (t.done ? " done" : "");
        div.textContent = "• " + (t.text || "(empty)");
        box.appendChild(div);
      }
    }

    if (mode === MODE.PLAN){
      newRoundBtn.style.display = "none";
      const canConfirm = totalTasks() > 0;
      mainBtn.textContent = "Confirm";
      mainBtn.disabled = !canConfirm;
      mainNote.textContent = canConfirm ? `Max ${MAX_PER_CAT}/cat.` : "Add 1+ todo.";
    } else {
      newRoundBtn.style.display = "inline-block";
      const settled = isRoundSettled();
      const hasTasks = totalTasks() > 0;
      mainBtn.textContent = settled ? "Settled ✅" : "Settle";
      mainBtn.disabled = !hasTasks || settled;
      mainNote.textContent = !hasTasks ? "No todos." : (settled ? "Settled. New round." : "Settle once → AR.");
    }
  }

  /***********************
   * Render: Category
   ***********************/
  function renderCategory(cat){
    catList.innerHTML = "";

    if (mode === MODE.PLAN){
      fabAdd.style.display = "block";
      fabAdd.disabled = state[cat].length >= MAX_PER_CAT;

      for (const task of state[cat]){
        const wrap = document.createElement("div");
        wrap.className = "swipeWrap";

        const delBg = document.createElement("div");
        delBg.className = "deleteBg";
        delBg.textContent = "Delete";
        wrap.appendChild(delBg);

        const row = document.createElement("div");
        row.className = "row";
        row.dataset.id = task.id;

        const textBox = document.createElement("div");
        textBox.className = "textBox";

        const textView = document.createElement("div");
        textView.className = "textView";
        textView.textContent = task.text || "tap to edit";

        const edit = document.createElement("input");
        edit.className = "editInput";
        edit.type = "text";
        edit.value = task.text || "";

        textView.addEventListener("click", () => {
          textView.style.display = "none";
          edit.style.display = "block";
          edit.focus();
          edit.setSelectionRange(edit.value.length, edit.value.length);
        });

        function commitEdit(){
          const v = edit.value.trim();
          task.text = v;
          textView.textContent = v || "tap to edit";
          edit.style.display = "none";
          textView.style.display = "block";
          persistAndRerender(cat);
        }
        edit.addEventListener("keydown", (e) => { if (e.key === "Enter") edit.blur(); });
        edit.addEventListener("blur", commitEdit);

        textBox.appendChild(textView);
        textBox.appendChild(edit);

        row.appendChild(textBox);
        wrap.appendChild(row);
        catList.appendChild(wrap);

        attachSwipeToDelete(row, () => {
          state[cat] = state[cat].filter(t => t.id !== task.id);
          persistAndRerender(cat);
        });
      }
    } else {
      fabAdd.style.display = "none";
      for (const task of state[cat]){
        const row = document.createElement("div");
        row.className = "rowCheck" + (task.done ? " done" : "");
        const text = document.createElement("div");
        text.className = "checkText";
        text.textContent = task.text || "(empty)";
        row.appendChild(text);
        catList.appendChild(row);
      }
    }
  }

  fabAdd.addEventListener("click", () => {
    if (mode !== MODE.PLAN) return;
    if (!currentCat) return;
    if (state[currentCat].length >= MAX_PER_CAT) return;

    state[currentCat].push({ id: cryptoId(), text: "", done: false });
    saveState();
    renderCategory(currentCat);

    requestAnimationFrame(() => {
      const lastRow = catList.querySelector(".row:last-child");
      if (!lastRow) return;
      const tv = lastRow.querySelector(".textView");
      tv && tv.click();
    });

    renderMatrix();
  });

  function persistAndRerender(cat){
    state[cat] = state[cat].slice(0, MAX_PER_CAT);
    saveState();
    renderCategory(cat);
    renderMatrix();
  }

  /***********************
   * Render: Settlement
   ***********************/
  function renderSettlement(){
    settleList.innerHTML = "";

    const settled = isRoundSettled();
    settleGoBtn.disabled = settled || totalTasks() === 0;
    settleNote.textContent = settled ? "Already settled." : "Mark done → AR.";

    for (const cat of CATS){
      const tasks = state[cat];
      if (!tasks.length) continue;

      const title = document.createElement("div");
      title.className = "groupTitle";
      title.innerHTML = CAT_META[cat].title.replace("<br>", " ");
      settleList.appendChild(title);

      for (const task of tasks){
        const row = document.createElement("div");
        row.className = "rowCheck" + (task.done ? " done" : "");

        const text = document.createElement("div");
        text.className = "checkText";
        text.textContent = task.text || "(empty)";

        const sw = document.createElement("label");
        sw.className = "switch";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = !!task.done;
        cb.disabled = settled;

        cb.addEventListener("change", () => {
          task.done = cb.checked;
          saveState();
          renderSettlement();
          renderMatrix();
        });

        const slider = document.createElement("span");
        slider.className = "slider";
        sw.appendChild(cb);
        sw.appendChild(slider);

        row.appendChild(text);
        row.appendChild(sw);
        settleList.appendChild(row);
      }
    }
  }

  /***********************
   * Swipe to delete (PLAN only)
   ***********************/
  function attachSwipeToDelete(rowEl, onDelete){
    let startX = 0;
    let currentX = 0;
    let dragging = false;

    rowEl.addEventListener("pointerdown", (e) => {
      if (mode !== MODE.PLAN) return;
      if (e.target.closest(".editInput")) return;
      dragging = true;
      startX = e.clientX;
      currentX = 0;
      rowEl.style.transition = "none";
      rowEl.setPointerCapture(e.pointerId);
    });

    rowEl.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - startX;
      currentX = Math.max(-120, Math.min(0, dx));
      rowEl.style.transform = `translateX(${currentX}px)`;
    });

    rowEl.addEventListener("pointerup", () => finishSwipe());
    rowEl.addEventListener("pointercancel", () => finishSwipe());

    function finishSwipe(){
      if (!dragging) return;
      dragging = false;
      rowEl.style.transition = "transform .15s ease";

      if (currentX < -80){
        rowEl.style.transform = "translateX(-120px)";
        setTimeout(() => onDelete(), 120);
      } else {
        rowEl.style.transform = "translateX(0px)";
      }
    }
  }

  /***********************
   * WebAR start/stop
   ***********************/
  const arOverlay = document.getElementById("arOverlay");
  const arDoneBtn = document.getElementById("arDoneBtn");
  const arHint    = document.getElementById("arHint");

  const arScene   = document.getElementById("arScene");
  const arTarget0 = document.getElementById("arTarget0");

  // A small retry helps if the plugin registers slightly later on some devices.
  async function startAR(){
    if (!arScene) return;

    arHint.textContent = "Starting…";

    // Let layout happen (overlay must be visible before camera init on some mobile browsers)
    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

    try { arScene.play && arScene.play(); } catch {}

    const tryGetSystem = () => arScene.systems && arScene.systems["mindar-image-system"];

    let sys = tryGetSystem();
    if (!sys){
      // Retry a few times (script load / A-Frame init timing)
      for (let i=0; i<12 && !sys; i++){
        await new Promise(r => setTimeout(r, 80));
        sys = tryGetSystem();
      }
    }

    if (!sys){
      const hasAFRAME = !!window.AFRAME;
      const hasComp = !!(window.AFRAME && AFRAME.components && AFRAME.components["mindar-image"]);
      arHint.textContent = hasComp ? "MindAR system missing." : "MindAR plugin not loaded.";
      console.error("AR init failed:", {
        hasAFRAME,
        hasMindarComponent: hasComp,
        sceneSystems: arScene.systems
      });
      return;
    }

    try{
      await sys.start();
      arHint.textContent = "Point at target.";
      try { arScene.resize && arScene.resize(); } catch {}
    }catch(e){
      arHint.textContent = "Camera blocked. Check permission.";
      console.error("sys.start() failed:", e);
    }
  }

  function stopAR(){
    try{
      const sys = arScene.systems && arScene.systems["mindar-image-system"];
      sys && sys.stop();
    }catch{}
  }

  if (arTarget0){
    arTarget0.addEventListener("targetFound", () => { arHint.textContent = "Found ✅"; });
    arTarget0.addEventListener("targetLost",  () => { arHint.textContent = "Point at target."; });
  }

  /***********************
   * Buttons
   ***********************/
  mainBtn.addEventListener("click", () => {
    if (mode === MODE.PLAN){
      if (totalTasks() === 0) return;

      for (const c of CATS) for (const t of state[c]) t.done = false;

      mode = MODE.CHECK;
      startRound();
      saveMode();
      saveState();
      showMatrix();
      return;
    }

    if (isRoundSettled()) return;
    if (totalTasks() === 0) return;
    showSettlement();
  });

  newRoundBtn.addEventListener("click", () => {
    if (!confirm("Clear + restart?")) return;

    try { stopAR(); } catch {}
    try { arOverlay.classList.remove("show"); } catch {}

    state = { IU:[], IN:[], NU:[], NN:[] };
    mode = MODE.PLAN;
    saveMode();
    saveState();
    clearRound();
    showMatrix();
  });

  settleGoBtn.addEventListener("click", () => {
    if (isRoundSettled()) return;
    if (totalTasks() === 0) return;

    settleRound({ total: totalTasks() });

    arOverlay.classList.add("show");
    startAR();
  });

  arDoneBtn.addEventListener("click", () => {
    stopAR();

    state = { IU:[], IN:[], NU:[], NN:[] };
    mode = MODE.PLAN;
    saveMode();
    saveState();
    clearRound();

    arOverlay.classList.remove("show");
    showMatrix();
  });

  /***********************
   * Initial
   ***********************/
  showMatrix();
</script>
</body>
</html>